package de.uniluebeck.itm.spyglass.drawing.primitive;

import java.util.Date;

import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.graphics.GC;
import org.eclipse.swt.graphics.Point;
import org.eclipse.swt.widgets.Display;

import de.uniluebeck.itm.spyglass.drawing.DrawingObject;
import de.uniluebeck.itm.spyglass.gui.view.DrawingArea;
import de.uniluebeck.itm.spyglass.gui.view.DrawingAreaTransformEvent;
import de.uniluebeck.itm.spyglass.gui.view.DrawingAreaTransformListener;
import de.uniluebeck.itm.spyglass.positions.AbsoluteRectangle;
import de.uniluebeck.itm.spyglass.positions.PixelPosition;
import de.uniluebeck.itm.spyglass.positions.PixelRectangle;
import de.uniluebeck.itm.spyglass.util.StringFormatter;

// --------------------------------------------------------------------------------
/**
 * Instances of this class represent a sensor node.
 * 
 * @author Sebastian Ebers
 * 
 */
public class NodeObject extends DrawingObject {
	
	private final int nodeID;
	
	private String denotation;
	
	private String stringFormatterResult;
	
	private volatile boolean isExtended;
	
	private int lineWidth;
	
	private AbsoluteRectangle boundingBox;
	
	/**
	 * True, if this nodeobject has registered <code>drawingAreaListener</code> with the drawing
	 * area.
	 */
	private boolean listenerConnected = false;
	
	/**
	 * The boundingbox (in Absolute coordinates) depends on the current zoom level. to make sure
	 * that we always return a correct bounding box, we listen for changes in the drawing area and
	 * update the bounding box accordingly.
	 * 
	 * Note: this hack is only neccessary, since a NodeObject "doesn't zoom". Most other
	 * DrawingObjects don't have to bother.
	 * 
	 * TODO: there is a lot of code duplication between this method and draw().
	 */
	private DrawingAreaTransformListener drawingAreaListener = new DrawingAreaTransformListener() {
		
		@Override
		public void handleEvent(final DrawingAreaTransformEvent e) {
			// get the information to be displayed
			final String string = getInformationString();
			
			// determine the size parameters of the rectangle which represents the node in respect
			// to the sting to be displayed
			final org.eclipse.swt.graphics.Image temp = new org.eclipse.swt.graphics.Image(
					e.drawingArea.getDisplay(), 500, 500);
			final GC tempGC = new GC(temp);
			final Point size = tempGC.textExtent(string == null ? "" : string);
			final int width = size.x + lineWidth + 1; // +1 for correct display with uneven line
			// width
			final int height = size.y + lineWidth + 1;
			
			// get the node's position in the drawing area
			final PixelPosition upperLeft = e.drawingArea.absPoint2PixelPoint(getPosition());
			
			// determine the bounding box
			boundingBox = determineBoundingBox(e.drawingArea, upperLeft, lineWidth, width, height);
			
			tempGC.dispose();
			temp.dispose();
		}
	};
	
	// --------------------------------------------------------------------------------
	/**
	 * Constructor
	 * 
	 * @param nodeID
	 *            the identifier of the node which is visualized
	 * @param denotation
	 *            the denotation of the visualization
	 */
	public NodeObject(final int nodeID, final String denotation) {
		this(nodeID, denotation, null, false);
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * Constructor
	 * 
	 * @param nodeID
	 *            the identifier of the node which is visualized
	 * @param denotation
	 *            the denotation of the visualization
	 * @param stringFormatterResult
	 *            detailed information generated by one or more {@link StringFormatter} (only shown
	 *            in extended mode)
	 * @param isExtended
	 *            indicates if the extended mode is active
	 */
	public NodeObject(final int nodeID, final String denotation,
			final String stringFormatterResult, final boolean isExtended) {
		this(nodeID, denotation, stringFormatterResult, isExtended, new int[] { 255, 0, 0 }, 1);
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * Constructor
	 * 
	 * @param nodeID
	 *            the identifier of the node which is visualized
	 * @param denotation
	 *            the denotation of the visualization
	 * @param stringFormatterResult
	 *            detailed information generated by one or more {@link StringFormatter} (only shown
	 *            in extended mode)
	 * @param isExtended
	 *            indicates if the extended mode is active
	 * @param lineColorRGB
	 *            the line colo's RGB values
	 * @param lineWidth
	 *            the line's width
	 */
	public NodeObject(final int nodeID, final String denotation,
			final String stringFormatterResult, final boolean isExtended, final int[] lineColorRGB,
			final int lineWidth) {
		super();
		super.setId((int) new Date().getTime());
		this.nodeID = nodeID;
		this.denotation = denotation;
		this.stringFormatterResult = stringFormatterResult;
		this.isExtended = isExtended;
		this.lineWidth = lineWidth;
		this.setColor(lineColorRGB[0], lineColorRGB[1], lineColorRGB[2]);
		
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * Updates the parameters
	 * 
	 * @param denotation
	 *            the denotation of the visualization
	 * @param stringFormatterResult
	 *            detailed information generated by one or more {@link StringFormatter} (only shown
	 *            in extended mode)
	 * @param isExtended
	 *            indicates if the extended mode is active
	 * @param lineColorRGB
	 *            the line colo's RGB values
	 * @param lineWidth
	 *            the line's width
	 */
	public void update(final String denotation, final String stringFormatterResult,
			final boolean isExtended, final int[] lineColorRGB, final int lineWidth) {
		this.denotation = denotation;
		this.stringFormatterResult = stringFormatterResult;
		this.isExtended = isExtended;
		this.lineWidth = lineWidth;
		this.setColor(lineColorRGB[0], lineColorRGB[1], lineColorRGB[2]);
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * @return the denotation
	 */
	public String getDenotation() {
		return denotation;
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * @param denotation
	 *            the denotation to set
	 */
	public void setDenotation(final String denotation) {
		this.denotation = denotation;
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * Returns detailed information generated by one or more {@link StringFormatter} (only shown in
	 * extended mode)
	 * 
	 * @return detailed information generated by one or more {@link StringFormatter} (only shown in
	 *         extended mode)
	 */
	public String getStringFormatterResult() {
		return stringFormatterResult;
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * Sets detailed information generated by one or more {@link StringFormatter} (only shown in
	 * extended mode)
	 * 
	 * @param stringFormatterResult
	 *            detailed information generated by one or more {@link StringFormatter} (only shown
	 *            in extended mode)
	 */
	public void setDescription(final String stringFormatterResult) {
		this.stringFormatterResult = stringFormatterResult;
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * @return the isExtended
	 */
	public boolean isExtended() {
		return isExtended;
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * Activates or deactivates the display of additional information
	 * 
	 * @param isExtended
	 *            if <code>true</code> the information will be displayed
	 * @param drawingArea
	 *            the current drawing area
	 */
	public void setExtended(final boolean isExtended, final DrawingArea drawingArea) {
		this.isExtended = isExtended;
		boundingBox = determineBoundingBox(drawingArea);
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * @return the lineWidth
	 */
	public int getLineWidth() {
		return lineWidth;
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * @param lineWidth
	 *            the lineWidth to set
	 */
	public void setLineWidth(final int lineWidth) {
		this.lineWidth = lineWidth;
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * @return the nodeID
	 */
	public int getNodeID() {
		return nodeID;
	}
	
	@Override
	public void draw(final DrawingArea drawingArea, final GC gc) {
		
		if (!listenerConnected) {
			listenerConnected = true;
			drawingArea.addDrawingAreaTransformListener(this.drawingAreaListener);
		}
		
		// set the colors and the width of the rectangle's line
		final Color color = new Color(null, this.getColorR(), this.getColorG(), this.getColorB());
		final Color bg = new Color(null, this.getBgColorR(), this.getBgColorG(), this.getBgColorB());
		gc.setForeground(color);
		gc.setBackground(bg);
		gc.setLineWidth(lineWidth);
		
		// get the information to be displayed
		final String string = getInformationString();
		
		// determine the size parameters of the rectangle which represents the node in respect to
		// the sting to be displayed
		final Point size = gc.textExtent(string);
		final int width = size.x + lineWidth + 1; // +1 for correct display with uneven line width
		final int height = size.y + lineWidth + 1;
		
		// get the node's position in the drawing area
		final PixelPosition upperLeft = drawingArea.absPoint2PixelPoint(this.getPosition());
		
		// determine the bounding box
		boundingBox = determineBoundingBox(drawingArea, upperLeft, lineWidth, width, height);
		
		// the new rectangle starts at the determined upper left position. Its with and height was
		// determined in respect to the text which is to be displayed
		final PixelRectangle pxRect = new PixelRectangle(upperLeft, width, height);
		gc.fillRectangle(pxRect.toSWTRectangle());
		gc.drawRectangle(pxRect.toSWTRectangle());
		
		// place the string inside the rectangle with respect to the side effects of the line width
		// (see above)
		gc.drawText(string, 1 + upperLeft.x + lineWidth / 2, 1 + upperLeft.y + lineWidth / 2);
		
		// dispose the no longer used colors
		color.dispose();
		bg.dispose();
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * Returns a string which is to be displayed in the node object.<br>
	 * This string contains information like e.g. the node's identifier and - in respect to the
	 * extended information status - the information of the available {@link StringFormatter}
	 * instances as well.
	 * 
	 * @return a string which is to be displayed in the node object
	 */
	private String getInformationString() {
		// get the detailed information by querying the string formatter
		final String descriptionString = (stringFormatterResult == null) ? ""
				: stringFormatterResult.toString();
		
		// create the string to be displayed
		final String string = (isExtended) ? denotation + "\r\n" + descriptionString : denotation;
		return string;
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * Returns the object's bounding box in absolute coordinate values
	 * 
	 * @param drawingArea
	 *            the current drawing area
	 * @param upperLeft
	 *            the upper left pixel position
	 * @param lineWidth
	 *            the object's line width (in pixel)
	 * @param width
	 *            the object's width (in pixel)
	 * @param height
	 *            the object's height (in pixel)
	 * @return the object's bounding box in absolute coordinate values
	 */
	public static AbsoluteRectangle determineBoundingBox(final DrawingArea drawingArea,
			final PixelPosition upperLeft, final int lineWidth, final int width, final int height) {
		
		// since the rectangle's line is spread according to its width with the actual position in
		// it's center, the upper left position of the bounding box has to adapt to this
		final int bbUpperLeftX = upperLeft.x - lineWidth / 2 + 1;
		final int bbUpperLeftY = upperLeft.y - lineWidth / 2 + 1;
		
		// the line width has to be counted twice because two lines with the same width are drawn on
		// the drawing area
		final int bbWidht = width + lineWidth;
		final int bbHeight = height + lineWidth;
		final PixelRectangle bbArea = new PixelRectangle(bbUpperLeftX, bbUpperLeftY, bbWidht,
				bbHeight);
		
		return drawingArea.pixelRect2AbsRect(bbArea);
	}
	
	// --------------------------------------------------------------------------------
	/**
	 * Returns the object's bounding box in absolute coordinate values
	 * 
	 * @param drawingArea
	 *            the current drawing area
	 * @return the object's bounding box in absolute coordinate values
	 */
	public AbsoluteRectangle determineBoundingBox(final DrawingArea drawingArea) {
		
		// get the information to be displayed
		final String string = getInformationString();
		
		// determine the size parameters of the rectangle which represents the node in respect to
		// the sting to be displayed
		final Point size = new GC(Display.getCurrent()).textExtent(string);
		final int width = size.x + lineWidth + 1; // +1 for correct display with uneven line width
		final int height = size.y + lineWidth + 1;
		
		final PixelPosition upperLeft = drawingArea.absPoint2PixelPoint(this.getPosition());
		
		// determine the bounding box
		return determineBoundingBox(drawingArea, upperLeft, lineWidth, width, height);
		
	}
	
	@Override
	public AbsoluteRectangle getBoundingBox() {
		if (boundingBox == null) {
			// temporary bugfix, used since draw() was
			// not yet called when this method is here
			// is called the first time
			return new AbsoluteRectangle(getPosition(), 1, 1);
		}
		return boundingBox;
	}
	
	@Override
	public String toString() {
		return "[Node " + nodeID + "]";
	}
	
}